---
import { getLangFromUrl, pathWithLocale, stripLangFromUrlOrId, buildElementProps } from "@/utils";
import { type PatchOptions } from "@/types/attributes";

interface NavLinkProps extends PatchOptions<"a"> {
  title: string;
  link: string;
  localized?: boolean;
}

const { title, link, localized = false, ...attributes } = Astro.props as NavLinkProps;

const base = Astro.site ?? Astro.url.origin;
const baseUrl = new URL(base);
const linkUrl = new URL(link, base);

const isExternal = linkUrl.origin !== baseUrl.origin;

const curPath = Astro.url.pathname;
const curLang = getLangFromUrl(Astro.url);

function hasLeadingLocale(p: string): boolean {
  return stripLangFromUrlOrId(p) !== p;
}

let href: string;
if (isExternal) {
  href = linkUrl.href;
} else {
  const pathOnly = linkUrl.pathname; // internal path
  const alreadyLocalized = localized || hasLeadingLocale(pathOnly);
  const localizedPath = alreadyLocalized ? pathOnly : pathWithLocale(curLang, pathOnly);
  href = localizedPath + linkUrl.search + linkUrl.hash;
}

// aria-current logic (only for internal links):
// - Exact match for locale root ("/en/")
// - Otherwise allow startsWith on locale-stripped paths
let isCurrent = false;
if (!isExternal) {
  const linkPathOnly = new URL(href, base).pathname;
  const curNoLang = stripLangFromUrlOrId(curPath);
  const linkNoLang = stripLangFromUrlOrId(linkPathOnly);

  const isLocaleRoot = linkNoLang === "/";

  // Exact match preserves trailing slashes comparison using raw paths
  isCurrent =
    curPath === linkPathOnly ||
    (!isLocaleRoot &&
      // Normalize for section-style comparison by ensuring the linkNoLang is a clean prefix
      (curNoLang === linkNoLang || curNoLang.startsWith(linkNoLang.replace(/\/$/, "") + "/")));
}

const built = buildElementProps<"a">({
  classList: [],
  attributes: {
    href: href,
    "aria-current": isCurrent ? "page" : undefined,
    ...attributes
  }
});
---

<a {...built}>{title}</a>

---
import { getLangFromUrl, pathWithLocale, stripLangFromUrlOrId } from "@/utils";

interface Props {
  title: string;
  link: string;
  localized?: boolean;
}

const { title, link, localized = false } = Astro.props as Props;

const base = Astro.site ?? Astro.url.origin;
const baseUrl = new URL(base);
const linkUrl = new URL(link, base);

const isExternal = linkUrl.origin !== baseUrl.origin;

const curPath = Astro.url.pathname;
const curLang = getLangFromUrl(Astro.url);

function hasLeadingLocale(p: string): boolean {
  return stripLangFromUrlOrId(p) !== p;
}

let href: string;
if (isExternal) {
  href = linkUrl.href;
} else {
  const pathOnly = linkUrl.pathname; // internal path
  const alreadyLocalized = localized || hasLeadingLocale(pathOnly);
  const localizedPath = alreadyLocalized ? pathOnly : pathWithLocale(curLang, pathOnly);
  href = localizedPath + linkUrl.search + linkUrl.hash;
}

// aria-current logic (only for internal links):
// - Exact match for locale root ("/en/")
// - Otherwise allow startsWith on locale-stripped paths
let isCurrent = false;
if (!isExternal) {
  const linkPathOnly = new URL(href, base).pathname;
  const curNoLang = stripLangFromUrlOrId(curPath);
  const linkNoLang = stripLangFromUrlOrId(linkPathOnly);

  const isLocaleRoot = linkNoLang === "/"; // link represents just the locale root

  // Exact match preserves trailing slashes comparison using raw paths
  isCurrent =
    curPath === linkPathOnly ||
    (!isLocaleRoot &&
      // Normalize for section-style comparison by ensuring the linkNoLang is a clean prefix
      (curNoLang === linkNoLang || curNoLang.startsWith(linkNoLang.replace(/\/$/, "") + "/")));
}
---

<a href={href} aria-current={isCurrent ? "page" : undefined}>{title}</a>
